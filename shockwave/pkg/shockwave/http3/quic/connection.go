package quic

import (
	"crypto/tls"
	"errors"
	"fmt"
	"net"
	"sync"
	"time"
)

// Connection states (RFC 9000 Section 5)
type ConnectionState uint8

const (
	StateInitial ConnectionState = iota
	StateHandshake
	StateActive
	StateClosing
	StateDraining
	StateClosed
)

func (s ConnectionState) String() string {
	switch s {
	case StateInitial:
		return "Initial"
	case StateHandshake:
		return "Handshake"
	case StateActive:
		return "Active"
	case StateClosing:
		return "Closing"
	case StateDraining:
		return "Draining"
	case StateClosed:
		return "Closed"
	default:
		return fmt.Sprintf("Unknown(%d)", s)
	}
}

var (
	ErrConnectionClosed   = errors.New("quic: connection closed")
	ErrInvalidState       = errors.New("quic: invalid connection state")
	ErrProtocolViolation  = errors.New("quic: protocol violation")
)

// Connection represents a QUIC connection
type Connection struct {
	// Network
	conn       net.PacketConn
	localAddr  net.Addr
	remoteAddr net.Addr
	isClient   bool
	isServer   bool

	// Connection IDs
	localConnID  ConnectionID
	remoteConnID ConnectionID
	destConnID   ConnectionID // Destination connection ID for initial packets

	// State
	stateMu sync.RWMutex
	state   ConnectionState

	// Crypto
	initialKeys     *CryptoKeys
	handshakeKeys   *CryptoKeys
	applicationKeys *CryptoKeys
	zeroRTTKeys     *CryptoKeys

	// TLS
	tlsHandler        *TLSHandler
	handshakeComplete bool
	tlsConn           *tls.Conn
	tlsConfig         *tls.Config

	// Streams
	streams *StreamManager

	// Packet handling
	sendMu      sync.Mutex
	sendQueue   []Frame
	packetNumber uint64
	largestAcked uint64

	recvMu       sync.Mutex
	recvPackets  []*Packet

	// Flow control
	maxData          uint64
	dataReceived     uint64
	dataSent         uint64
	peerMaxData      uint64

	// Transport parameters
	localParams  *TransportParameters
	remoteParams *TransportParameters

	// Error handling
	closeErr     error
	closeErrCode uint64

	// Timing
	createdAt time.Time
	idleTimer *time.Timer
}

// Config holds configuration for a QUIC connection
type Config struct {
	TLSConfig          *tls.Config
	TransportParams    *TransportParameters
	MaxIdleTimeout     time.Duration
	KeepAlive          bool
	EnableDatagrams    bool
	Enable0RTT         bool
}

// DefaultConfig returns a default configuration
func DefaultConfig(isClient bool) *Config {
	return &Config{
		TLSConfig:       NewQUICTLSConfig(isClient),
		TransportParams: DefaultTransportParameters(),
		MaxIdleTimeout:  30 * time.Second,
		KeepAlive:       true,
		EnableDatagrams: true,
		Enable0RTT:      false,
	}
}

// NewConnection creates a new QUIC connection
func NewConnection(conn net.PacketConn, remoteAddr net.Addr, config *Config, isClient bool) (*Connection, error) {
	localConnID, err := GenerateConnectionID(8)
	if err != nil {
		return nil, err
	}

	c := &Connection{
		conn:         conn,
		localAddr:    conn.LocalAddr(),
		remoteAddr:   remoteAddr,
		isClient:     isClient,
		isServer:     !isClient,
		localConnID:  localConnID,
		state:        StateInitial,
		tlsConfig:    config.TLSConfig,
		localParams:  config.TransportParams,
		sendQueue:    make([]Frame, 0, 32),
		recvPackets:  make([]*Packet, 0, 32),
		maxData:      config.TransportParams.InitialMaxData,
		peerMaxData:  config.TransportParams.InitialMaxData,
		createdAt:    time.Now(),
	}

	c.streams = newStreamManager(c)

	// Generate initial keys (will be regenerated by TLS handler)
	c.initialKeys, err = NewInitialKeys(localConnID, isClient)
	if err != nil {
		return nil, err
	}

	// Create TLS handler
	c.tlsHandler, err = NewTLSHandler(c, config.TLSConfig, isClient)
	if err != nil {
		return nil, fmt.Errorf("failed to create TLS handler: %w", err)
	}

	return c, nil
}

// Start initiates the connection handshake
func (c *Connection) Start() error {
	c.stateMu.Lock()
	if c.state != StateInitial {
		c.stateMu.Unlock()
		return ErrInvalidState
	}
	c.state = StateHandshake
	c.stateMu.Unlock()

	// Start TLS handshake
	if err := c.tlsHandler.Start(); err != nil {
		return fmt.Errorf("failed to start TLS handshake: %w", err)
	}

	// Wait for handshake to complete (with timeout in production)
	if err := c.tlsHandler.WaitForHandshake(); err != nil {
		return fmt.Errorf("TLS handshake failed: %w", err)
	}

	c.stateMu.Lock()
	c.state = StateActive
	c.stateMu.Unlock()

	return nil
}

// sendClientInitial sends the client's Initial packet
func (c *Connection) sendClientInitial() error {
	// Create random destination connection ID for server
	destConnID, err := GenerateConnectionID(8)
	if err != nil {
		return err
	}
	c.remoteConnID = destConnID

	// Create CRYPTO frame with ClientHello
	// In a real implementation, this would come from crypto/tls
	cryptoData := []byte("CLIENT_HELLO_PLACEHOLDER")

	cryptoFrame := &CryptoFrame{
		Offset: 0,
		Data:   cryptoData,
	}

	// Create Initial packet
	packet := &Packet{
		Header: PacketHeader{
			IsLongHeader:    true,
			Version:         Version1,
			Type:            PacketTypeInitial,
			DestConnID:      c.remoteConnID,
			SrcConnID:       c.localConnID,
			Token:           nil,
			PacketNumber:    c.nextPacketNumber(),
			PacketNumberLen: 2,
		},
	}

	// Encode frame into payload
	payload, err := cryptoFrame.AppendTo(nil)
	if err != nil {
		return err
	}

	// Pad to minimum size (1200 bytes)
	if len(payload) < MinInitialPacket-50 { // Leave room for header
		padding := &PaddingFrame{Length: MinInitialPacket - 50 - len(payload)}
		payload, _ = padding.AppendTo(payload)
	}

	packet.Payload = payload
	packet.Header.Length = uint64(packet.Header.PacketNumberLen + len(packet.Payload))

	// Protect and send
	protectedPacket, err := c.initialKeys.ProtectPacket(packet)
	if err != nil {
		return err
	}

	_, err = c.conn.WriteTo(protectedPacket, c.remoteAddr)
	if err != nil {
		return err
	}

	c.state = StateHandshake
	return nil
}

// HandlePacket processes an incoming packet
func (c *Connection) HandlePacket(data []byte, addr net.Addr) error {
	c.recvMu.Lock()
	defer c.recvMu.Unlock()

	// Parse packet (unprotected header only)
	packet, _, err := ParsePacket(data)
	if err != nil {
		return err
	}

	// Select appropriate keys based on packet type
	var keys *CryptoKeys
	switch packet.Header.Type {
	case PacketTypeInitial:
		keys = c.initialKeys
	case PacketTypeHandshake:
		keys = c.handshakeKeys
	case PacketType1RTT:
		keys = c.applicationKeys
	case PacketType0RTT:
		keys = c.zeroRTTKeys
	default:
		return fmt.Errorf("quic: unsupported packet type %v", packet.Header.Type)
	}

	if keys == nil {
		return errors.New("quic: no keys for packet type")
	}

	// Unprotect packet
	unprotectedPacket, err := keys.UnprotectPacket(data, len(c.localConnID))
	if err != nil {
		return err
	}

	// Process frames in payload
	return c.processFrames(unprotectedPacket.Payload)
}

// processFrames processes frames from a decrypted packet
func (c *Connection) processFrames(payload []byte) error {
	offset := 0

	for offset < len(payload) {
		frame, n, err := ParseFrame(payload[offset:])
		if err != nil {
			return err
		}
		offset += n

		if err := c.handleFrame(frame); err != nil {
			return err
		}
	}

	return nil
}

// handleFrame handles a single frame
func (c *Connection) handleFrame(frame Frame) error {
	switch f := frame.(type) {
	case *PingFrame:
		// Send ACK
		c.queueFrame(&AckFrame{
			LargestAcked: c.largestAcked,
			AckDelay:     0,
			Ranges:       []AckRange{{Gap: 0, Length: 1}},
		})

	case *AckFrame:
		// Update largest acked
		if f.LargestAcked > c.largestAcked {
			c.largestAcked = f.LargestAcked
		}

	case *CryptoFrame:
		// Process TLS handshake data
		return c.handleCryptoFrame(f)

	case *StreamFrame:
		// Process stream data
		stream := c.streams.GetStream(f.StreamID)
		return stream.handleStreamFrame(f)

	case *ResetStreamFrame:
		stream := c.streams.GetStream(f.StreamID)
		return stream.handleResetStream(f)

	case *StopSendingFrame:
		stream := c.streams.GetStream(f.StreamID)
		return stream.handleStopSending(f)

	case *MaxDataFrame:
		c.peerMaxData = f.MaximumData

	case *MaxStreamDataFrame:
		stream := c.streams.GetStream(f.StreamID)
		stream.updateSendMaxData(f.MaximumData)

	case *MaxStreamsFrame:
		c.streams.UpdateMaxStreams(f.MaximumStreams, f.Bidirectional)

	case *ConnectionCloseFrame:
		return c.handleConnectionClose(f)

	case *HandshakeDoneFrame:
		c.stateMu.Lock()
		c.state = StateActive
		c.stateMu.Unlock()

	case *DatagramFrame:
		// Handle unreliable datagram (RFC 9221)
		return c.handleDatagram(f)
	}

	return nil
}

// handleCryptoFrame processes a CRYPTO frame
func (c *Connection) handleCryptoFrame(frame *CryptoFrame) error {
	// Determine encryption level based on current state
	level := c.tlsHandler.GetReadLevel()

	// Pass to TLS handler
	if err := c.tlsHandler.HandleCryptoFrame(frame, level); err != nil {
		return fmt.Errorf("failed to handle CRYPTO frame: %w", err)
	}

	// Transition state based on handshake progress
	c.stateMu.Lock()
	if c.state == StateInitial {
		c.state = StateHandshake
	}
	c.stateMu.Unlock()

	return nil
}

// sendCryptoFrame sends a CRYPTO frame at the specified encryption level
func (c *Connection) sendCryptoFrame(frame *CryptoFrame, level EncryptionLevel) error {
	c.sendMu.Lock()
	defer c.sendMu.Unlock()

	// Encode frame
	payload, err := frame.AppendTo(nil)
	if err != nil {
		return err
	}

	// Determine packet type based on encryption level
	var packetType PacketType
	var keys *CryptoKeys

	switch level {
	case EncryptionLevelInitial:
		packetType = PacketTypeInitial
		keys = c.initialKeys
	case EncryptionLevelHandshake:
		packetType = PacketTypeHandshake
		keys = c.handshakeKeys
	case EncryptionLevelApplication:
		packetType = PacketType1RTT
		keys = c.applicationKeys
	default:
		return fmt.Errorf("invalid encryption level for CRYPTO frame: %v", level)
	}

	if keys == nil {
		return fmt.Errorf("no keys available for encryption level %v", level)
	}

	// Create packet
	isLong := (packetType != PacketType1RTT)
	packet := &Packet{
		Header: PacketHeader{
			IsLongHeader:    isLong,
			Type:            packetType,
			DestConnID:      c.remoteConnID,
			SrcConnID:       c.localConnID,
			PacketNumber:    c.nextPacketNumber(),
			PacketNumberLen: 2,
		},
		Payload: payload,
	}

	// For Initial packets, add padding to minimum size
	if packetType == PacketTypeInitial && len(payload) < MinInitialPacket-100 {
		padding := &PaddingFrame{Length: MinInitialPacket - 100 - len(payload)}
		packet.Payload, _ = padding.AppendTo(packet.Payload)
	}

	if isLong {
		packet.Header.Length = uint64(packet.Header.PacketNumberLen + len(packet.Payload))
	}

	// Protect and send
	protectedPacket, err := keys.ProtectPacket(packet)
	if err != nil {
		return fmt.Errorf("failed to protect packet: %w", err)
	}

	_, err = c.conn.WriteTo(protectedPacket, c.remoteAddr)
	return err
}

// handleConnectionClose processes a CONNECTION_CLOSE frame
func (c *Connection) handleConnectionClose(frame *ConnectionCloseFrame) error {
	c.stateMu.Lock()
	defer c.stateMu.Unlock()

	c.state = StateDraining
	c.closeErrCode = frame.ErrorCode
	c.closeErr = fmt.Errorf("peer closed connection: code=0x%x, reason=%s",
		frame.ErrorCode, string(frame.ReasonPhrase))

	return c.closeErr
}

// handleDatagram processes a DATAGRAM frame (RFC 9221)
func (c *Connection) handleDatagram(frame *DatagramFrame) error {
	// Application would handle this through a callback
	// For now, just acknowledge receipt
	return nil
}

// OpenStream opens a new bidirectional stream
func (c *Connection) OpenStream() (*Stream, error) {
	return c.streams.OpenStream(true, c.isClient)
}

// OpenUniStream opens a new unidirectional stream
func (c *Connection) OpenUniStream() (*Stream, error) {
	return c.streams.OpenStream(false, c.isClient)
}

// AcceptStream waits for and accepts an incoming stream
func (c *Connection) AcceptStream() (*Stream, error) {
	// In a real implementation, this would block until a stream is available
	// For now, return an error
	return nil, errors.New("quic: AcceptStream not yet implemented")
}

// SendDatagram sends an unreliable datagram (RFC 9221)
func (c *Connection) SendDatagram(data []byte) error {
	frame := &DatagramFrame{Data: data}
	c.queueFrame(frame)
	return c.flush()
}

// queueFrame queues a frame for transmission
func (c *Connection) queueFrame(frame Frame) {
	c.sendMu.Lock()
	defer c.sendMu.Unlock()

	c.sendQueue = append(c.sendQueue, frame)
}

// flush sends all queued frames
func (c *Connection) flush() error {
	c.sendMu.Lock()
	defer c.sendMu.Unlock()

	if len(c.sendQueue) == 0 {
		return nil
	}

	// Encode all queued frames into payload
	payload := make([]byte, 0, MaxPacketSize)
	for _, frame := range c.sendQueue {
		var err error
		payload, err = frame.AppendTo(payload)
		if err != nil {
			return err
		}
	}

	c.sendQueue = c.sendQueue[:0] // Clear queue

	// Create packet
	packet := &Packet{
		Header: PacketHeader{
			IsLongHeader:    false,
			Type:            PacketType1RTT,
			DestConnID:      c.remoteConnID,
			PacketNumber:    c.nextPacketNumber(),
			PacketNumberLen: 2,
		},
		Payload: payload,
	}

	// Protect packet
	keys := c.applicationKeys
	if keys == nil {
		keys = c.initialKeys // Fallback during handshake
	}

	protectedPacket, err := keys.ProtectPacket(packet)
	if err != nil {
		return err
	}

	// Send packet
	_, err = c.conn.WriteTo(protectedPacket, c.remoteAddr)
	return err
}

// Close closes the connection gracefully
func (c *Connection) Close() error {
	return c.CloseWithError(0, "")
}

// CloseWithError closes the connection with an error code
func (c *Connection) CloseWithError(errorCode uint64, reason string) error {
	c.stateMu.Lock()
	defer c.stateMu.Unlock()

	if c.state == StateClosed {
		return nil
	}

	c.state = StateClosing

	// Send CONNECTION_CLOSE frame
	frame := &ConnectionCloseFrame{
		ErrorCode:    errorCode,
		ReasonPhrase: []byte(reason),
		IsAppError:   true,
	}

	c.queueFrame(frame)
	c.flush()

	c.state = StateClosed
	return nil
}

// State returns the current connection state
func (c *Connection) State() ConnectionState {
	c.stateMu.RLock()
	defer c.stateMu.RUnlock()
	return c.state
}

// LocalAddr returns the local address
func (c *Connection) LocalAddr() net.Addr {
	return c.conn.LocalAddr()
}

// RemoteAddr returns the remote address
func (c *Connection) RemoteAddr() net.Addr {
	return c.remoteAddr
}

// nextPacketNumber returns the next packet number and increments the counter
func (c *Connection) nextPacketNumber() uint64 {
	pn := c.packetNumber
	c.packetNumber++
	return pn
}

// ConnectionID returns the local connection ID
func (c *Connection) ConnectionID() ConnectionID {
	return c.localConnID
}

// RemoteConnectionID returns the remote connection ID
func (c *Connection) RemoteConnectionID() ConnectionID {
	return c.remoteConnID
}
