# GoX Quick Start Guide

Get started with GoX in 5 minutes!

---

## Installation

```bash
# Install GoX compiler
go install github.com/yourusername/gox/cmd/goxc@latest

# Verify installation
goxc --version
```

---

## Your First Component

### 1. Create a new project

```bash
mkdir my-gox-app
cd my-gox-app
go mod init my-gox-app

# Add GoX runtime dependency
go get github.com/yourusername/gox/runtime
```

### 2. Create your first component

Create `Counter.gox`:

```gox
package main

import "gox"

component Counter() {
    count, setCount := gox.UseState[int](0)

    increment := func() {
        setCount(count + 1)
    }

    render {
        <div className="counter">
            <h1>Count: {count}</h1>
            <button onClick={increment}>Increment</button>
        </div>
    }

    style {
        .counter {
            text-align: center;
            padding: 20px;
        }

        .counter button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border-radius: 4px;
        }

        .counter button:hover {
            background: #0056b3;
        }
    }
}
```

### 3. Build (SSR Mode)

```bash
# Compile .gox to .go
goxc build --mode=ssr -o dist/ Counter.gox

# Build Go binary
go build -o app dist/*.go

# Run
./app
```

### 4. Create SSR Entry Point

Create `main.gox`:

```gox
package main

import (
    "fmt"
    "net/http"
    "gox/runtime/ssr"
)

func main() {
    http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        counter := NewCounter()
        html := counter.Render()

        fmt.Fprintf(w, `
<!DOCTYPE html>
<html>
<head>
    <title>GoX App</title>
    <style>
        %s
    </style>
</head>
<body>
    <div id="root">%s</div>
</body>
</html>
        `, getStyles(), html)
    })

    fmt.Println("Server running on http://localhost:8080")
    http.ListenAndServe(":8080", nil)
}

func getStyles() string {
    // CSS will be auto-generated by goxc
    return generatedStyles
}
```

Build and run:

```bash
goxc build --mode=ssr -o dist/ *.gox
go build -o app dist/*.go
./app
```

Visit http://localhost:8080

---

## WASM Mode (CSR)

### 1. Build for WASM

```bash
# Compile .gox to .go with CSR mode
goxc build --mode=csr -o dist/ Counter.gox

# Build WASM binary
GOOS=js GOARCH=wasm go build -o dist/app.wasm dist/*.go
```

### 2. Create HTML Entry Point

Create `index.html`:

```html
<!DOCTYPE html>
<html>
<head>
    <title>GoX WASM App</title>
    <meta charset="utf-8"/>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div id="root"></div>

    <script src="wasm_exec.js"></script>
    <script>
        const go = new Go();
        WebAssembly.instantiateStreaming(fetch("app.wasm"), go.importObject)
            .then((result) => {
                go.run(result.instance);
            });
    </script>
</body>
</html>
```

### 3. Copy WASM Support Files

```bash
# Copy wasm_exec.js from Go installation
cp "$(go env GOROOT)/misc/wasm/wasm_exec.js" dist/
```

### 4. Create WASM Entry Point

Create `main_wasm.gox`:

```gox
//go:build js && wasm

package main

import (
    "syscall/js"
    "gox/runtime/wasm"
)

func main() {
    // Get root element
    root := js.Global().Get("document").Call("getElementById", "root")

    // Create and mount component
    counter := NewCounter()
    reconciler := wasm.NewReconciler(counter, root)
    reconciler.Mount()

    // Keep program running
    select {}
}
```

### 5. Serve and Test

```bash
# Simple Python server
cd dist
python3 -m http.server 8080

# Or use GoX dev server
goxc dev --port 8080
```

Visit http://localhost:8080

---

## Development Workflow

### Watch Mode

Automatically rebuild on file changes:

```bash
goxc watch --mode=ssr src/
```

### Dev Server with Live Reload

```bash
goxc dev --mode=csr --port 3000 src/
```

---

## Common Patterns

### State Management

```gox
component TodoApp() {
    todos, setTodos := gox.UseState[[]Todo]([]Todo{})
    input, setInput := gox.UseState[string]("")

    addTodo := func() {
        if input != "" {
            newTodos := append(todos, Todo{Text: input, Done: false})
            setTodos(newTodos)
            setInput("")
        }
    }

    render {
        <div>
            <input value={input} onInput={/* handler */} />
            <button onClick={addTodo}>Add</button>
            <ul>
                {todos.map(func(todo Todo, i int) *gox.VNode {
                    return <li key={i}>{todo.Text}</li>
                })}
            </ul>
        </div>
    }
}
```

### Side Effects

```gox
component DataFetcher() {
    data, setData := gox.UseState[*Data](nil)
    loading, setLoading := gox.UseState[bool](true)

    gox.UseEffect(func() func() {
        go func() {
            result := fetchData()
            setData(result)
            setLoading(false)
        }()

        return nil
    }, []interface{}{})

    render {
        <div>
            {loading ? <div>Loading...</div> : <DataDisplay data={data} />}
        </div>
    }
}
```

### Component Composition

```gox
component Card(title string, children ...*gox.VNode) {
    render {
        <div className="card">
            <div className="card-header">
                <h3>{title}</h3>
            </div>
            <div className="card-body">
                {children}
            </div>
        </div>
    }
}

// Usage
<Card title="My Card">
    <p>Card content goes here</p>
    <button>Click me</button>
</Card>
```

### Context for Global State

```gox
// contexts/theme.gox
package contexts

import "gox"

var ThemeContext = gox.CreateContext[string]("light")

// App.gox
component App() {
    theme, setTheme := gox.UseState[string]("dark")

    toggleTheme := func() {
        if theme == "light" {
            setTheme("dark")
        } else {
            setTheme("light")
        }
    }

    render {
        <ThemeContext.Provider value={theme}>
            <Header onToggleTheme={toggleTheme} />
            <MainContent />
        </ThemeContext.Provider>
    }
}

// Header.gox
component Header(onToggleTheme func()) {
    theme := gox.UseContext[string](ThemeContext)

    render {
        <header className={theme}>
            <h1>My App</h1>
            <button onClick={onToggleTheme}>Toggle Theme</button>
        </header>
    }
}
```

---

## Project Structure

Recommended structure for larger apps:

```
my-gox-app/
├── src/
│   ├── components/
│   │   ├── Button.gox
│   │   ├── Card.gox
│   │   └── Input.gox
│   ├── pages/
│   │   ├── Home.gox
│   │   ├── About.gox
│   │   └── Contact.gox
│   ├── contexts/
│   │   ├── theme.gox
│   │   └── user.gox
│   ├── hooks/
│   │   ├── useFetch.go
│   │   └── useLocalStorage.go
│   ├── utils/
│   │   └── helpers.go
│   └── App.gox
├── public/
│   ├── index.html
│   └── assets/
├── dist/
├── go.mod
├── go.sum
└── README.md
```

---

## Performance Tips

### 1. Memoize Expensive Computations

```gox
component ExpensiveComponent(items []Item) {
    // Only recompute when items change
    processed := gox.UseMemo[[]ProcessedItem](func() []ProcessedItem {
        return processItems(items)
    }, []interface{}{items})

    render {
        <div>{/* use processed */}</div>
    }
}
```

### 2. Optimize Callbacks

```gox
component Parent() {
    count, setCount := gox.UseState[int](0)

    // Callback won't change unless count changes
    handleClick := gox.UseCallback[func()](func() {
        setCount(count + 1)
    }, []interface{}{count})

    render {
        <Child onClick={handleClick} />
    }
}
```

### 3. Use Keys for Lists

```gox
render {
    <ul>
        {items.map(func(item Item, i int) *gox.VNode {
            // Use unique ID as key, not index
            return <li key={item.ID}>{item.Name}</li>
        })}
    </ul>
}
```

### 4. Lazy Load Components

```gox
component App() {
    showHeavy, setShowHeavy := gox.UseState[bool](false)

    render {
        <div>
            <button onClick={func() { setShowHeavy(true) }}>
                Load Heavy Component
            </button>
            {showHeavy && <HeavyComponent />}
        </div>
    }
}
```

---

## Testing

### Unit Testing Components

```go
// Counter_test.go
package main

import (
    "testing"
)

func TestCounterRender(t *testing.T) {
    counter := NewCounter()
    html := counter.Render()

    if !strings.Contains(html, "Count: 0") {
        t.Error("Expected initial count to be 0")
    }
}

func TestCounterIncrement(t *testing.T) {
    counter := NewCounter()

    // Simulate increment
    counter.setCount(1)

    html := counter.Render()
    if !strings.Contains(html, "Count: 1") {
        t.Error("Expected count to be 1 after increment")
    }
}
```

### Integration Testing (WASM)

```go
//go:build js && wasm

func TestComponentMount(t *testing.T) {
    // Create a mock DOM environment
    // Test component mounting and updates
}
```

---

## Debugging

### SSR Mode

Use standard Go debugging:

```go
component MyComponent() {
    count, setCount := gox.UseState[int](0)

    // Add debug prints
    fmt.Printf("Rendering with count: %d\n", count)

    render {
        <div>{count}</div>
    }
}
```

### WASM Mode

Use browser console:

```gox
//go:build js && wasm

import (
    "syscall/js"
    "fmt"
)

component MyComponent() {
    count, setCount := gox.UseState[int](0)

    // Log to browser console
    js.Global().Get("console").Call("log", fmt.Sprintf("Count: %d", count))

    render {
        <div>{count}</div>
    }
}
```

### Debug Build

```bash
# Build with debug symbols
goxc build --mode=csr --debug -o dist/ src/*.gox

# Or use environment variable
GOX_DEBUG=1 goxc build --mode=csr -o dist/ src/*.gox
```

---

## Next Steps

- Read the [Syntax Specification](SYNTAX_SPEC.md)
- Check out the [Implementation Guide](IMPLEMENTATION_GUIDE.md)
- Explore [example projects](examples/)
- Join the community Discord
- Contribute on GitHub

---

## Troubleshooting

### Build Errors

**"component keyword not recognized"**
- Make sure you're using `.gox` file extension
- Verify goxc is installed correctly

**"hook used outside component"**
- Hooks must be called directly in component body
- Don't call hooks conditionally or in loops

### Runtime Errors (WASM)

**"Cannot read property of undefined"**
- Check that WASM is loaded before accessing DOM
- Ensure wasm_exec.js is correctly loaded

**"Memory access out of bounds"**
- May be caused by large state objects
- Try breaking down state into smaller pieces

### Performance Issues

**Slow SSR rendering**
- Profile your component tree
- Optimize expensive computations with memoization
- Consider caching rendered HTML

**WASM bundle too large**
- Use TinyGo for smaller binaries: `tinygo build -o app.wasm`
- Enable optimization flags
- Split code into multiple WASM modules

---

## Resources

- Documentation: https://gox.dev/docs
- API Reference: https://gox.dev/api
- Examples: https://github.com/gox/examples
- Discord: https://discord.gg/gox
- Twitter: @gox_lang
